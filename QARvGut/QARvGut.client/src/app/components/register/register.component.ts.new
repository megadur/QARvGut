// ---------------------------------------
// Story 1.2: User Registration & Profile Management
// Registration Component - SENIOR DEV REFACTORED
// ---------------------------------------

import { Component, OnInit, inject, OnDestroy } from '@angular/core';
import { FormBuilder, FormGroup, ReactiveFormsModule, Validators } from '@angular/forms';
import { Router, RouterModule } from '@angular/router';
import { CommonModule } from '@angular/common';
import { TranslateModule } from '@ngx-translate/core';
import { Subject, takeUntil } from 'rxjs';

import { AlertService, MessageSeverity } from '../../services/alert.service';
import { AccountService } from '../../services/account.service';
import { AuthService } from '../../services/auth.service';
import { FormValidationService } from '../../services/form-validation.service';
import { Utilities } from '../../services/utilities';
import { UserRegistration } from '../../models/user-edit.model';
import { PasswordValidators } from '../../validators/password-validators';

@Component({
  selector: 'app-register',
  templateUrl: './register.component.html',
  styleUrl: './register.component.scss',
  imports: [ReactiveFormsModule, CommonModule, RouterModule, TranslateModule]
})
export class RegisterComponent implements OnInit, OnDestroy {
  private readonly destroy$ = new Subject<void>();
  private readonly formBuilder = inject(FormBuilder);
  private readonly alertService = inject(AlertService);
  private readonly accountService = inject(AccountService);
  private readonly authService = inject(AuthService);
  private readonly router = inject(Router);
  private readonly formValidationService = inject(FormValidationService);

  registrationForm!: FormGroup;
  isLoading = false;
  showValidationErrors = false;

  readonly availableRoles = ['Assessor']; // Only Assessor role can self-register

  // Form field getters for template binding
  get userName() { return this.registrationForm.get('userName'); }
  get email() { return this.registrationForm.get('email'); }
  get firstName() { return this.registrationForm.get('firstName'); }
  get lastName() { return this.registrationForm.get('lastName'); }
  get password() { return this.registrationForm.get('password'); }
  get confirmPassword() { return this.registrationForm.get('confirmPassword'); }

  ngOnInit(): void {
    this.initializeComponent();
  }

  ngOnDestroy(): void {
    this.destroy$.next();
    this.destroy$.complete();
  }

  private initializeComponent(): void {
    this.buildRegistrationForm();
    this.handleAuthenticationState();
  }

  private buildRegistrationForm(): void {
    this.registrationForm = this.formBuilder.group({
      userName: ['', [
        Validators.required,
        Validators.minLength(2),
        Validators.maxLength(200)
      ]],
      email: ['', [
        Validators.required,
        Validators.email,
        Validators.maxLength(200)
      ]],
      firstName: ['', [
        Validators.required,
        Validators.maxLength(50)
      ]],
      lastName: ['', [
        Validators.required,
        Validators.maxLength(50)
      ]],
      jobTitle: ['', [
        Validators.maxLength(100)
      ]],
      phoneNumber: ['', [
        Validators.maxLength(20)
      ]],
      department: ['', [
        Validators.maxLength(100)
      ]],
      phone: ['', [
        Validators.maxLength(20)
      ]],
      contactInfo: ['', [
        Validators.maxLength(500)
      ]],
      password: ['', [
        Validators.required,
        PasswordValidators.strengthValidator()
      ]],
      confirmPassword: ['', [
        Validators.required
      ]],
      role: ['Assessor', [
        Validators.required
      ]],
      acceptTerms: [false, [
        Validators.requiredTrue
      ]]
    }, {
      validators: PasswordValidators.matchValidator()
    });
  }

  private handleAuthenticationState(): void {
    // Redirect if already logged in
    if (this.authService.isLoggedIn && !this.authService.isSessionExpired) {
      this.authService.redirectLoginUser();
    }
  }

  onSubmit(): void {
    this.showValidationErrors = true;

    if (this.registrationForm.valid) {
      this.processRegistration();
    } else {
      this.handleValidationErrors();
    }
  }

  private processRegistration(): void {
    this.setLoadingState(true);
    const registrationData = this.createRegistrationPayload();

    this.accountService.registerUser(registrationData)
      .pipe(takeUntil(this.destroy$))
      .subscribe({
        next: (user) => this.handleRegistrationSuccess(user, registrationData.roles[0]),
        error: (error) => this.handleRegistrationError(error)
      });
  }

  private createRegistrationPayload(): UserRegistration {
    const formData = this.registrationForm.value;

    return {
      userName: formData.userName,
      email: formData.email,
      password: formData.password,
      confirmPassword: formData.confirmPassword,
      fullName: `${formData.firstName} ${formData.lastName}`.trim(),
      jobTitle: formData.jobTitle || '',
      phoneNumber: formData.phoneNumber || '',
      department: formData.department || null,
      phone: formData.phone || null,
      contactInfo: formData.contactInfo || null,
      roles: [formData.role]
    };
  }

  private handleRegistrationSuccess(user: any, role: string): void {
    this.setLoadingState(false);

    const approvalMessage = role !== 'Assessor'
      ? ' Administrator approval is required before you can access all features.'
      : '';

    this.alertService.showMessage(
      'Registration Successful',
      `Welcome ${user.userName}! Your account has been created successfully.${approvalMessage}`,
      MessageSeverity.success
    );

    // Navigate to login after delay for user to read success message
    setTimeout(() => {
      this.router.navigate(['/login']);
    }, 2000);
  }

  private handleRegistrationError(error: any): void {
    this.setLoadingState(false);

    if (this.isServerValidationError(error)) {
      this.handleServerValidationErrors(error.error.errors);
    } else {
      const errorMessage = Utilities.getHttpResponseMessage(error) || 'An error occurred during registration';
      this.alertService.showStickyMessage('Registration Failed', errorMessage, MessageSeverity.error, error);
    }
  }

  private isServerValidationError(error: any): boolean {
    return error?.status === 400 && error?.error?.errors;
  }

  private handleServerValidationErrors(serverErrors: Record<string, string[]>): void {
    const errorMappings = {
      'Email': 'This email address is already registered.',
      'UserName': 'This username is already taken.',
      'NewPassword': (errors: string[]) => errors.join(' ')
    };

    Object.entries(serverErrors).forEach(([field, errors]) => {
      const errorMessage = field === 'NewPassword'
        ? errorMappings[field](errors)
        : errorMappings[field as keyof typeof errorMappings];

      if (errorMessage) {
        this.alertService.showMessage('Registration Failed', errorMessage as string, MessageSeverity.error);
      }
    });
  }

  private handleValidationErrors(): void {
    const validationResult = this.formValidationService.validateForm(this.registrationForm);

    // Show first error to user
    if (validationResult.errors.length > 0) {
      const firstError = validationResult.errors[0];
      this.alertService.showMessage(
        this.getErrorCaption(firstError.error),
        firstError.message,
        MessageSeverity.error
      );
    }

    // Focus first invalid field for better UX
    this.formValidationService.focusFirstInvalidField(this.registrationForm);
  }

  private getErrorCaption(errorType: string): string {
    const captions: Record<string, string> = {
      'required': 'Required Field',
      'email': 'Invalid Email',
      'passwordStrength': 'Password Requirements',
      'passwordMismatch': 'Password Mismatch'
    };

    return captions[errorType] || 'Validation Error';
  }

  private setLoadingState(loading: boolean): void {
    this.isLoading = loading;

    if (loading) {
      this.alertService.startLoadingMessage('Creating your account...');
    } else {
      this.alertService.stopLoadingMessage();
    }
  }
}
